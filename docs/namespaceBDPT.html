<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RayTracer: BDPT Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RayTracer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">BDPT Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing.  
<a href="namespaceBDPT.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3582af31b65a257cdd36088d963105f9" id="r_a3582af31b65a257cdd36088d963105f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a3582af31b65a257cdd36088d963105f9">Path</a> = std::vector&lt; <a class="el" href="structRayTracer_1_1Vertex.html">RayTracer::Vertex</a> &gt;</td></tr>
<tr class="memdesc:a3582af31b65a257cdd36088d963105f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a sequence of vertices forming a light path (either camera or light sub-path).  <br /></td></tr>
<tr class="separator:a3582af31b65a257cdd36088d963105f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adce9dce622e7280388e22e606a5dc021" id="r_adce9dce622e7280388e22e606a5dc021"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#adce9dce622e7280388e22e606a5dc021">local_rand01</a> ()</td></tr>
<tr class="memdesc:adce9dce622e7280388e22e606a5dc021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a pseudo-random double precision number in the range [0, 1).  <br /></td></tr>
<tr class="separator:adce9dce622e7280388e22e606a5dc021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e289175022f1a88f47313428feec24" id="r_ad5e289175022f1a88f47313428feec24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#ad5e289175022f1a88f47313428feec24">safe_normalize</a> (const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;v)</td></tr>
<tr class="memdesc:ad5e289175022f1a88f47313428feec24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a 3D vector safely.  <br /></td></tr>
<tr class="separator:ad5e289175022f1a88f47313428feec24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acbb06ab1d4577bca00f14059992930" id="r_a1acbb06ab1d4577bca00f14059992930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a1acbb06ab1d4577bca00f14059992930">reflect_vec</a> (const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;v_incident_towards_surface, const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;normal_n)</td></tr>
<tr class="memdesc:a1acbb06ab1d4577bca00f14059992930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the reflection vector for a given incident vector and surface normal.  <br /></td></tr>
<tr class="separator:a1acbb06ab1d4577bca00f14059992930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fec5f2ec1d792eae40d0848f8996208" id="r_a9fec5f2ec1d792eae40d0848f8996208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a9fec5f2ec1d792eae40d0848f8996208">refract_vec</a> (const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;incident_I_pointing_towards_surface, const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;N_interface_from_inc_to_trans, double eta_ratio_incident_over_transmitted)</td></tr>
<tr class="memdesc:a9fec5f2ec1d792eae40d0848f8996208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the refraction vector using Snell's Law.  <br /></td></tr>
<tr class="separator:a9fec5f2ec1d792eae40d0848f8996208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ec950e727f4e915bd06a2161e4d07d" id="r_a87ec950e727f4e915bd06a2161e4d07d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a87ec950e727f4e915bd06a2161e4d07d">fresnel_schlick_scalar</a> (double cos_incident_angle_wrt_normal, double n1_incident_medium, double n2_transmitted_medium)</td></tr>
<tr class="memdesc:a87ec950e727f4e915bd06a2161e4d07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Fresnel reflection coefficient using Schlick's approximation.  <br /></td></tr>
<tr class="separator:a87ec950e727f4e915bd06a2161e4d07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78a31c8b409b8a582aba9e6382e47d7" id="r_ac78a31c8b409b8a582aba9e6382e47d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#ac78a31c8b409b8a582aba9e6382e47d7">sample_cosine_hemisphere_bdpt</a> (const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;normal, double &amp;pdf_out)</td></tr>
<tr class="memdesc:ac78a31c8b409b8a582aba9e6382e47d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a direction on a cosine-weighted hemisphere defined by a normal vector.  <br /></td></tr>
<tr class="separator:ac78a31c8b409b8a582aba9e6382e47d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fed679ec7471cdddc185b603b5b9e6" id="r_af6fed679ec7471cdddc185b603b5b9e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#af6fed679ec7471cdddc185b603b5b9e6">sample_uniform_sphere_direction_bdpt</a> (double &amp;pdf_out)</td></tr>
<tr class="memdesc:af6fed679ec7471cdddc185b603b5b9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a direction uniformly over the unit sphere.  <br /></td></tr>
<tr class="separator:af6fed679ec7471cdddc185b603b5b9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe233458983a00aef9744e509ffdc03d" id="r_afe233458983a00aef9744e509ffdc03d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#afe233458983a00aef9744e509ffdc03d">get_material_albedo_from_rec</a> (const <a class="el" href="structRayTracer_1_1Material.html">RayTracer::Material</a> &amp;mat, const <a class="el" href="structRayTracer_1_1HitRecord.html">RayTracer::HitRecord</a> &amp;rec)</td></tr>
<tr class="memdesc:afe233458983a00aef9744e509ffdc03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the effective albedo of a material at a hit point.  <br /></td></tr>
<tr class="separator:afe233458983a00aef9744e509ffdc03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd866b76b9db502c6680adc57cb5bcf" id="r_a4dd866b76b9db502c6680adc57cb5bcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a4dd866b76b9db502c6680adc57cb5bcf">eval_bsdf</a> (const <a class="el" href="structRayTracer_1_1HitRecord.html">RayTracer::HitRecord</a> &amp;rec, const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;wo_world, const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;wi_world, const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;N_geom, bool wi_is_transmission_hint)</td></tr>
<tr class="memdesc:a4dd866b76b9db502c6680adc57cb5bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bidirectional Scattering Distribution Function (BSDF) for a pair of directions.  <br /></td></tr>
<tr class="separator:a4dd866b76b9db502c6680adc57cb5bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f9bfd0f08650b73e92bba978495157" id="r_a75f9bfd0f08650b73e92bba978495157"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a75f9bfd0f08650b73e92bba978495157">sample_bsdf</a> (const <a class="el" href="structRayTracer_1_1HitRecord.html">RayTracer::HitRecord</a> &amp;rec, const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;wo_world, <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;wi_sampled_world, double &amp;pdf_solid_angle_wi, <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;bsdf_term_value, bool &amp;scattered_is_delta)</td></tr>
<tr class="memdesc:a75f9bfd0f08650b73e92bba978495157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples an incoming light direction (wi_sampled_world) based on material properties and an outgoing view direction (wo_world).  <br /></td></tr>
<tr class="separator:a75f9bfd0f08650b73e92bba978495157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0f987dc8cc4003a2ed232f4db218d0" id="r_a2c0f987dc8cc4003a2ed232f4db218d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a2c0f987dc8cc4003a2ed232f4db218d0">generate_subpath_fixed</a> (const <a class="el" href="classRayTracer_1_1Scene.html">RayTracer::Scene</a> &amp;scene, <a class="el" href="structRayTracer_1_1Ray.html">RayTracer::Ray</a> current_ray, int max_bounces, <a class="el" href="namespaceBDPT.html#a3582af31b65a257cdd36088d963105f9">Path</a> &amp;path_vertices, bool is_camera_path, const <a class="el" href="structUtils_1_1RenderParams.html">Utils::RenderParams</a> &amp;params)</td></tr>
<tr class="memdesc:a2c0f987dc8cc4003a2ed232f4db218d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sub-path (either camera or light) by iteratively sampling BSDFs and tracing rays.  <br /></td></tr>
<tr class="separator:a2c0f987dc8cc4003a2ed232f4db218d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d781fb6b3823098ebeda02af94150f6" id="r_a2d781fb6b3823098ebeda02af94150f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a2d781fb6b3823098ebeda02af94150f6">sample_light_source_fixed</a> (const <a class="el" href="classRayTracer_1_1Scene.html">RayTracer::Scene</a> &amp;scene, <a class="el" href="structRayTracer_1_1Ray.html">RayTracer::Ray</a> &amp;light_ray_out, <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;Le_value_out, double &amp;pdf_pos_area_light_out, double &amp;pdf_emit_dir_solid_angle_out, <a class="el" href="structRayTracer_1_1Vertex.html">RayTracer::Vertex</a> &amp;light_vertex_out)</td></tr>
<tr class="memdesc:a2d781fb6b3823098ebeda02af94150f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a light source from the scene to initiate a light sub-path.  <br /></td></tr>
<tr class="separator:a2d781fb6b3823098ebeda02af94150f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c0260c49402e07e663bcde99cb2642" id="r_a91c0260c49402e07e663bcde99cb2642"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a91c0260c49402e07e663bcde99cb2642">geometry_term_fixed</a> (const <a class="el" href="classRayTracer_1_1Scene.html">RayTracer::Scene</a> &amp;scene, const <a class="el" href="structRayTracer_1_1Vertex.html">RayTracer::Vertex</a> &amp;v0, const <a class="el" href="structRayTracer_1_1Vertex.html">RayTracer::Vertex</a> &amp;v1)</td></tr>
<tr class="memdesc:a91c0260c49402e07e663bcde99cb2642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the geometric term G(v0, v1) for connecting two vertices in <a class="el" href="namespaceBDPT.html" title="Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing.">BDPT</a>.  <br /></td></tr>
<tr class="separator:a91c0260c49402e07e663bcde99cb2642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde17a7a16768e8aa2c00328e56103c3" id="r_afde17a7a16768e8aa2c00328e56103c3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#afde17a7a16768e8aa2c00328e56103c3">mis_balance</a> (double p_cam, double p_light)</td></tr>
<tr class="memdesc:afde17a7a16768e8aa2c00328e56103c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Multiple Importance Sampling (MIS) weight using the balance heuristic.  <br /></td></tr>
<tr class="separator:afde17a7a16768e8aa2c00328e56103c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064e091114e0e07937d6ca79742f5b3a" id="r_a064e091114e0e07937d6ca79742f5b3a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a064e091114e0e07937d6ca79742f5b3a">mis_power</a> (double p_cam, double p_light)</td></tr>
<tr class="memdesc:a064e091114e0e07937d6ca79742f5b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Multiple Importance Sampling (MIS) weight using the power heuristic (exponent = 2).  <br /></td></tr>
<tr class="separator:a064e091114e0e07937d6ca79742f5b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2405a3b45e542640c4f7ca3aa10e0c27" id="r_a2405a3b45e542640c4f7ca3aa10e0c27"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a2405a3b45e542640c4f7ca3aa10e0c27">mis_weight_fixed</a> (const <a class="el" href="namespaceBDPT.html#a3582af31b65a257cdd36088d963105f9">Path</a> &amp;cam_path, size_t s_cam_idx, const <a class="el" href="namespaceBDPT.html#a3582af31b65a257cdd36088d963105f9">Path</a> &amp;light_path, size_t t_light_idx, int k_total)</td></tr>
<tr class="memdesc:a2405a3b45e542640c4f7ca3aa10e0c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the MIS weight for a combined path strategy in <a class="el" href="namespaceBDPT.html" title="Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing.">BDPT</a>.  <br /></td></tr>
<tr class="separator:a2405a3b45e542640c4f7ca3aa10e0c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb080fc04aff1a21b0eabc660f3fbf34" id="r_abb080fc04aff1a21b0eabc660f3fbf34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#abb080fc04aff1a21b0eabc660f3fbf34">renderBDPT</a> (const <a class="el" href="classRayTracer_1_1Scene.html">RayTracer::Scene</a> &amp;scene, const <a class="el" href="structUtils_1_1RenderParams.html">Utils::RenderParams</a> &amp;params, bool showProgress)</td></tr>
<tr class="memdesc:abb080fc04aff1a21b0eabc660f3fbf34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the scene using Bidirectional Path Tracing (<a class="el" href="namespaceBDPT.html" title="Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing.">BDPT</a>).  <br /></td></tr>
<tr class="separator:abb080fc04aff1a21b0eabc660f3fbf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a67a92ff05b952759e35747db08a1827f" id="r_a67a92ff05b952759e35747db08a1827f"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a67a92ff05b952759e35747db08a1827f">RR_START_DEPTH</a> = 3</td></tr>
<tr class="memdesc:a67a92ff05b952759e35747db08a1827f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth at which Russian Roulette path termination begins.  <br /></td></tr>
<tr class="separator:a67a92ff05b952759e35747db08a1827f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafbdd2a8f1955dfa015f4e9887a8889" id="r_abafbdd2a8f1955dfa015f4e9887a8889"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#abafbdd2a8f1955dfa015f4e9887a8889">PDF_EPSILON</a> = 1e-7</td></tr>
<tr class="memdesc:abafbdd2a8f1955dfa015f4e9887a8889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small epsilon value for Probability Density Function (PDF) comparisons to avoid division by zero or instability.  <br /></td></tr>
<tr class="separator:abafbdd2a8f1955dfa015f4e9887a8889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab653062b770735172c3daa2ab51d2c4c" id="r_ab653062b770735172c3daa2ab51d2c4c"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#ab653062b770735172c3daa2ab51d2c4c">GEOMETRY_EPSILON</a> = 1e-8</td></tr>
<tr class="memdesc:ab653062b770735172c3daa2ab51d2c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small epsilon value for geometric comparisons (e.g., vector lengths, distances) to handle floating-point inaccuracies.  <br /></td></tr>
<tr class="separator:ab653062b770735172c3daa2ab51d2c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac681c8b8f1bebfa2679882a62f3f76ea" id="r_ac681c8b8f1bebfa2679882a62f3f76ea"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#ac681c8b8f1bebfa2679882a62f3f76ea">THROUGHPUT_EPSILON_SQ</a> = 1e-12</td></tr>
<tr class="memdesc:ac681c8b8f1bebfa2679882a62f3f76ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared epsilon for path throughput magnitude checks; paths with throughput below this are considered negligible.  <br /></td></tr>
<tr class="separator:ac681c8b8f1bebfa2679882a62f3f76ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa723c28285176a297dfbab55f9964eae" id="r_aa723c28285176a297dfbab55f9964eae"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#aa723c28285176a297dfbab55f9964eae">RAY_OFFSET_EPSILON</a> = 1e-4</td></tr>
<tr class="memdesc:aa723c28285176a297dfbab55f9964eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small distance to offset rays from surfaces to prevent self-intersection.  <br /></td></tr>
<tr class="separator:aa723c28285176a297dfbab55f9964eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4847d6ecec82c5533d5c5cee248c0f" id="r_a7a4847d6ecec82c5533d5c5cee248c0f"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a7a4847d6ecec82c5533d5c5cee248c0f">ONE_OVER_PI</a> = 1.0 / <a class="el" href="BDPT_8hpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></td></tr>
<tr class="memdesc:a7a4847d6ecec82c5533d5c5cee248c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precomputed value of 1/PI.  <br /></td></tr>
<tr class="separator:a7a4847d6ecec82c5533d5c5cee248c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9524ac4202c8d0f8446ec7bd525f1b" id="r_a2b9524ac4202c8d0f8446ec7bd525f1b"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBDPT.html#a2b9524ac4202c8d0f8446ec7bd525f1b">ONE_OVER_FOUR_PI</a> = 1.0 / (4.0 * <a class="el" href="BDPT_8hpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>)</td></tr>
<tr class="memdesc:a2b9524ac4202c8d0f8446ec7bd525f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precomputed value of 1/(4*PI).  <br /></td></tr>
<tr class="separator:a2b9524ac4202c8d0f8446ec7bd525f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a3582af31b65a257cdd36088d963105f9" name="a3582af31b65a257cdd36088d963105f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3582af31b65a257cdd36088d963105f9">&#9670;&#160;</a></span>Path</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBDPT.html#a3582af31b65a257cdd36088d963105f9">BDPT::Path</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a sequence of vertices forming a light path (either camera or light sub-path). </p>
<p>Each vertex in the path stores geometric information, material properties, BSDF throughput, and PDFs. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4dd866b76b9db502c6680adc57cb5bcf" name="a4dd866b76b9db502c6680adc57cb5bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd866b76b9db502c6680adc57cb5bcf">&#9670;&#160;</a></span>eval_bsdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> BDPT::eval_bsdf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRayTracer_1_1HitRecord.html">RayTracer::HitRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>wo_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>wi_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>N_geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wi_is_transmission_hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bidirectional Scattering Distribution Function (BSDF) for a pair of directions. </p>
<p>This function is primarily used for path connection strategies in <a class="el" href="namespaceBDPT.html" title="Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing.">BDPT</a>. It provides an approximate BSDF value for non-delta scattering events. For delta BSDFs (perfect mirrors/glass), this function may return zero as their contribution is handled by specific sampling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>The hit record at the scattering surface. </td></tr>
    <tr><td class="paramname">wo_world</td><td>The outgoing direction (from surface to observer/next vertex) in world space. </td></tr>
    <tr><td class="paramname">wi_world</td><td>The incoming direction (from light/previous vertex to surface) in world space. </td></tr>
    <tr><td class="paramname">N_geom</td><td>The geometric normal of the surface (unused in this simplified version, but common in full BSDFs). </td></tr>
    <tr><td class="paramname">wi_is_transmission_hint</td><td>A hint if the incoming direction might be due to transmission (unused here). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The BSDF value (RGB vector) for the given directions. Returns (0,0,0) if the interaction is delta or non-contributing for connections. </dd></dl>

</div>
</div>
<a id="a87ec950e727f4e915bd06a2161e4d07d" name="a87ec950e727f4e915bd06a2161e4d07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ec950e727f4e915bd06a2161e4d07d">&#9670;&#160;</a></span>fresnel_schlick_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BDPT::fresnel_schlick_scalar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cos_incident_angle_wrt_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n1_incident_medium</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n2_transmitted_medium</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Fresnel reflection coefficient using Schlick's approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cos_incident_angle_wrt_normal</td><td>Cosine of the angle between the incident ray and the surface normal. Should be positive. </td></tr>
    <tr><td class="paramname">n1_incident_medium</td><td>Index of Refraction (IOR) of the incident medium. </td></tr>
    <tr><td class="paramname">n2_transmitted_medium</td><td>Index of Refraction (IOR) of the transmitted medium. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar Fresnel reflection coefficient (reflectance). Returns 1.0 for Total Internal Reflection (TIR). </dd></dl>

</div>
</div>
<a id="a2c0f987dc8cc4003a2ed232f4db218d0" name="a2c0f987dc8cc4003a2ed232f4db218d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0f987dc8cc4003a2ed232f4db218d0">&#9670;&#160;</a></span>generate_subpath_fixed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BDPT::generate_subpath_fixed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRayTracer_1_1Scene.html">RayTracer::Scene</a> &amp;&#160;</td>
          <td class="paramname"><em>scene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRayTracer_1_1Ray.html">RayTracer::Ray</a>&#160;</td>
          <td class="paramname"><em>current_ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_bounces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceBDPT.html#a3582af31b65a257cdd36088d963105f9">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_camera_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structUtils_1_1RenderParams.html">Utils::RenderParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a sub-path (either camera or light) by iteratively sampling BSDFs and tracing rays. </p>
<p>The path starts from <code>current_ray</code> and extends up to <code>max_bounces</code>. Vertices are stored in <code>path_vertices</code>. Russian Roulette is used for path termination. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">scene</td><td>The scene containing geometry and materials. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">current_ray</td><td>The initial ray for starting the sub-path. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">max_bounces</td><td>The maximum number of bounces (path segments) allowed for this sub-path. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path_vertices</td><td>The generated list of vertices forming the sub-path. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">is_camera_path</td><td>True if generating a camera sub-path, false for a light sub-path. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">params</td><td>Global rendering parameters (unused in this specific simplified version but often needed). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices generated in the <code>path_vertices</code> list. </dd></dl>

</div>
</div>
<a id="a91c0260c49402e07e663bcde99cb2642" name="a91c0260c49402e07e663bcde99cb2642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c0260c49402e07e663bcde99cb2642">&#9670;&#160;</a></span>geometry_term_fixed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BDPT::geometry_term_fixed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRayTracer_1_1Scene.html">RayTracer::Scene</a> &amp;&#160;</td>
          <td class="paramname"><em>scene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRayTracer_1_1Vertex.html">RayTracer::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRayTracer_1_1Vertex.html">RayTracer::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the geometric term G(v0, v1) for connecting two vertices in <a class="el" href="namespaceBDPT.html" title="Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing.">BDPT</a>. </p>
<p>The geometric term accounts for the inverse square distance between vertices, cosine factors at both vertices (if they are non-delta surfaces), and visibility (occlusion). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene</td><td>The scene used for visibility checks (tracing shadow rays). </td></tr>
    <tr><td class="paramname">v0</td><td>The first vertex of the connection segment. </td></tr>
    <tr><td class="paramname">v1</td><td>The second vertex of the connection segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The geometric term G. Returns 0.0 if vertices are occluded or coincident. </dd></dl>

</div>
</div>
<a id="afe233458983a00aef9744e509ffdc03d" name="afe233458983a00aef9744e509ffdc03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe233458983a00aef9744e509ffdc03d">&#9670;&#160;</a></span>get_material_albedo_from_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> BDPT::get_material_albedo_from_rec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRayTracer_1_1Material.html">RayTracer::Material</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRayTracer_1_1HitRecord.html">RayTracer::HitRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the effective albedo of a material at a hit point. </p>
<p>Considers the material's base albedo and any diffuse texture map applied. If a diffuse texture exists, it samples the texture at the given UV coordinates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The material of the hit surface. </td></tr>
    <tr><td class="paramname">rec</td><td>The hit record containing UV coordinates and other surface information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The albedo color (RGB vector) of the material at the hit point. </dd></dl>

</div>
</div>
<a id="adce9dce622e7280388e22e606a5dc021" name="adce9dce622e7280388e22e606a5dc021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce9dce622e7280388e22e606a5dc021">&#9670;&#160;</a></span>local_rand01()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BDPT::local_rand01 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a pseudo-random double precision number in the range [0, 1). </p>
<p>This function uses a thread-local random number generator to ensure thread safety and distinct sequences for parallel execution contexts (e.g., OpenMP). </p><dl class="section return"><dt>Returns</dt><dd>A random double between 0.0 (inclusive) and 1.0 (exclusive). </dd></dl>

</div>
</div>
<a id="afde17a7a16768e8aa2c00328e56103c3" name="afde17a7a16768e8aa2c00328e56103c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde17a7a16768e8aa2c00328e56103c3">&#9670;&#160;</a></span>mis_balance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BDPT::mis_balance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p_cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p_light</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Multiple Importance Sampling (MIS) weight using the balance heuristic. </p>
<p>Weight = pdf_camera / (pdf_camera + pdf_light). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cam</td><td>The PDF of generating the combined path using the camera sub-path strategy. </td></tr>
    <tr><td class="paramname">p_light</td><td>The PDF of generating the combined path using the light sub-path strategy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MIS weight. </dd></dl>

</div>
</div>
<a id="a064e091114e0e07937d6ca79742f5b3a" name="a064e091114e0e07937d6ca79742f5b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064e091114e0e07937d6ca79742f5b3a">&#9670;&#160;</a></span>mis_power()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double BDPT::mis_power </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p_cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p_light</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Multiple Importance Sampling (MIS) weight using the power heuristic (exponent = 2). </p>
<p>Weight = (pdf_camera^2) / (pdf_camera^2 + pdf_light^2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cam</td><td>The PDF of generating the combined path using the camera sub-path strategy. </td></tr>
    <tr><td class="paramname">p_light</td><td>The PDF of generating the combined path using the light sub-path strategy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MIS weight. </dd></dl>

</div>
</div>
<a id="a2405a3b45e542640c4f7ca3aa10e0c27" name="a2405a3b45e542640c4f7ca3aa10e0c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2405a3b45e542640c4f7ca3aa10e0c27">&#9670;&#160;</a></span>mis_weight_fixed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double BDPT::mis_weight_fixed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBDPT.html#a3582af31b65a257cdd36088d963105f9">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>cam_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s_cam_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceBDPT.html#a3582af31b65a257cdd36088d963105f9">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>light_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>t_light_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_total</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the MIS weight for a combined path strategy in <a class="el" href="namespaceBDPT.html" title="Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing.">BDPT</a>. </p>
<p>This function implements Veach's power heuristic (exponent 2) for combining path sampling strategies. It considers the forward PDFs (pdfFwd) and reverse PDFs (pdfRev) stored in path vertices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cam</td><td>The camera sub-path vertices (y_0, ..., y_s). </td></tr>
    <tr><td class="paramname">s</td><td>The number of segments in the camera sub-path being considered for this strategy (connects vertex y_s). </td></tr>
    <tr><td class="paramname">light</td><td>The light sub-path vertices (z_0, ..., z_t). </td></tr>
    <tr><td class="paramname">t</td><td>The number of segments in the light sub-path being considered for this strategy (connects vertex z_t). </td></tr>
    <tr><td class="paramname">k_total</td><td>The total number of segments in the combined path (s + t for direct connection, s + t + 1 for connection strategy). This parameter is currently unused in the provided Veach's reference implementation style but is common in some MIS formulations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MIS weight for the given strategy.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This implementation is based on Veach's thesis / PBRT's interpretation for <a class="el" href="namespaceBDPT.html" title="Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing.">BDPT</a> MIS. Ensure <code>pdfFwd</code> stores P+(v_i-1 -&gt; v_i) and <code>pdfRev</code> stores P-(v_i+1 -&gt; v_i). For path y_0...y_s connected to z_t...z_0, the path vertices are (y_0...y_s, z_t...z_0). s = index of camera vertex (y_s), t = index of light vertex (z_t). Strategy (s,t) connects y_s and z_t. Number of segments in camera path part = s. Number of segments in light path part = t. This function assumes <code>s</code> refers to index of last camera vertex, <code>t</code> for last light vertex in MIS sense. </dd></dl>

</div>
</div>
<a id="a1acbb06ab1d4577bca00f14059992930" name="a1acbb06ab1d4577bca00f14059992930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acbb06ab1d4577bca00f14059992930">&#9670;&#160;</a></span>reflect_vec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> BDPT::reflect_vec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>v_incident_towards_surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>normal_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the reflection vector for a given incident vector and surface normal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v_incident_towards_surface</td><td>The incident vector, pointing towards the surface. </td></tr>
    <tr><td class="paramname">normal_n</td><td>The surface normal, assumed to be unit length and pointing outwards from the surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reflection vector. </dd></dl>

</div>
</div>
<a id="a9fec5f2ec1d792eae40d0848f8996208" name="a9fec5f2ec1d792eae40d0848f8996208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fec5f2ec1d792eae40d0848f8996208">&#9670;&#160;</a></span>refract_vec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> BDPT::refract_vec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>incident_I_pointing_towards_surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>N_interface_from_inc_to_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eta_ratio_incident_over_transmitted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the refraction vector using Snell's Law. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incident_I_pointing_towards_surface</td><td>The incident vector, pointing towards the surface. </td></tr>
    <tr><td class="paramname">N_interface_from_inc_to_trans</td><td>The interface normal, oriented from the incident medium towards the transmitted medium. Assumed unit length. </td></tr>
    <tr><td class="paramname">eta_ratio_incident_over_transmitted</td><td>The ratio of refractive indices (n_incident / n_transmitted). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The refraction vector. Returns a zero vector if Total Internal Reflection (TIR) occurs. </dd></dl>

</div>
</div>
<a id="abb080fc04aff1a21b0eabc660f3fbf34" name="abb080fc04aff1a21b0eabc660f3fbf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb080fc04aff1a21b0eabc660f3fbf34">&#9670;&#160;</a></span>renderBDPT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &gt; BDPT::renderBDPT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRayTracer_1_1Scene.html">RayTracer::Scene</a> &amp;&#160;</td>
          <td class="paramname"><em>scene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structUtils_1_1RenderParams.html">Utils::RenderParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showProgress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders the scene using Bidirectional Path Tracing (<a class="el" href="namespaceBDPT.html" title="Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing.">BDPT</a>). </p>
<p>This function orchestrates the <a class="el" href="namespaceBDPT.html" title="Contains constants, utility functions, and the main rendering logic for Bidirectional Path Tracing.">BDPT</a> algorithm:</p><ol type="1">
<li>For each pixel and each sample: a. Generate a camera sub-path. b. Generate a light sub-path. c. Combine sub-paths using various strategies (camera hits emitter, light hits camera, connect paths). d. Weight contributions using Multiple Importance Sampling (MIS).</li>
<li>Accumulate radiance contributions to form the final image. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene</td><td>The scene to render, containing camera, geometry, materials, and lights. </td></tr>
    <tr><td class="paramname">params</td><td>Rendering parameters (image dimensions, samples per pixel, max path depth). </td></tr>
    <tr><td class="paramname">showProgress</td><td>If true, prints progress updates to the console. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of RGB color values representing the rendered image framebuffer. </dd></dl>
</li>
</ol>

</div>
</div>
<a id="ad5e289175022f1a88f47313428feec24" name="ad5e289175022f1a88f47313428feec24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e289175022f1a88f47313428feec24">&#9670;&#160;</a></span>safe_normalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> BDPT::safe_normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes a 3D vector safely. </p>
<p>If the vector's length is below a small epsilon (GEOMETRY_EPSILON), a zero vector is returned to prevent division by zero or instability. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector to normalize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized vector, or a zero vector if the original length is negligible. </dd></dl>

</div>
</div>
<a id="a75f9bfd0f08650b73e92bba978495157" name="a75f9bfd0f08650b73e92bba978495157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f9bfd0f08650b73e92bba978495157">&#9670;&#160;</a></span>sample_bsdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BDPT::sample_bsdf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRayTracer_1_1HitRecord.html">RayTracer::HitRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>wo_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>wi_sampled_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>pdf_solid_angle_wi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>bsdf_term_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>scattered_is_delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples an incoming light direction (wi_sampled_world) based on material properties and an outgoing view direction (wo_world). </p>
<p>This function implements importance sampling for various material types (metallic, dielectric, diffuse). It determines the next path direction, the BSDF value for that direction, the PDF of sampling it, and whether the scattering event was a delta distribution (e.g., perfect mirror). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">rec</td><td>The hit record at the scattering surface. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">wo_world</td><td>The outgoing direction from the surface (e.g., towards camera or previous vertex on light path), in world space. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wi_sampled_world</td><td>The sampled incoming light direction (or next path direction) in world space. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pdf_solid_angle_wi</td><td>The Probability Density Function (PDF) of sampling wi_sampled_world, in solid angle measure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bsdf_term_value</td><td>The BSDF throughput value (f_s * cos(theta_i) / pdf_wi if not absorbing pdf here) for the sampled direction. Typically (f_s * albedo_or_specular_tint). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scattered_is_delta</td><td>True if the scattering event is a delta distribution (e.g., perfect mirror/glass), false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac78a31c8b409b8a582aba9e6382e47d7" name="ac78a31c8b409b8a582aba9e6382e47d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78a31c8b409b8a582aba9e6382e47d7">&#9670;&#160;</a></span>sample_cosine_hemisphere_bdpt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> BDPT::sample_cosine_hemisphere_bdpt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>pdf_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Samples a direction on a cosine-weighted hemisphere defined by a normal vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">normal</td><td>The normal vector defining the hemisphere's orientation (local Z-axis). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pdf_out</td><td>The Probability Density Function (PDF) of sampling the returned direction, in solid angle measure (cos(theta)/PI). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A randomly sampled direction vector on the hemisphere. </dd></dl>

</div>
</div>
<a id="a2d781fb6b3823098ebeda02af94150f6" name="a2d781fb6b3823098ebeda02af94150f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d781fb6b3823098ebeda02af94150f6">&#9670;&#160;</a></span>sample_light_source_fixed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BDPT::sample_light_source_fixed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRayTracer_1_1Scene.html">RayTracer::Scene</a> &amp;&#160;</td>
          <td class="paramname"><em>scene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRayTracer_1_1Ray.html">RayTracer::Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>light_ray_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> &amp;&#160;</td>
          <td class="paramname"><em>Le_value_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>pdf_pos_area_light_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>pdf_emit_dir_solid_angle_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRayTracer_1_1Vertex.html">RayTracer::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>light_vertex_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples a light source from the scene to initiate a light sub-path. </p>
<p>Selects a light source (either from explicit lights list or emissive scene objects) and samples a point on it and an initial emission direction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">scene</td><td>The scene containing light sources and emissive objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">light_ray_out</td><td>The initial ray emitted from the sampled light source. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Le_value_out</td><td>The radiance (L_e) of the sampled light source at the point of emission. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pdf_pos_area_light_out</td><td>The PDF of sampling the position on the light source (area measure for area lights, discrete prob for point lights). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pdf_emit_dir_solid_angle_out</td><td>The PDF of sampling the initial emission direction (solid angle measure). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">light_vertex_out</td><td>The first vertex (z_0) of the light sub-path, representing the point on the light source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a light source was successfully sampled, false otherwise. </dd></dl>

</div>
</div>
<a id="af6fed679ec7471cdddc185b603b5b9e6" name="af6fed679ec7471cdddc185b603b5b9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fed679ec7471cdddc185b603b5b9e6">&#9670;&#160;</a></span>sample_uniform_sphere_direction_bdpt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMath_1_1Vector3D.html">Math::Vector3D</a> BDPT::sample_uniform_sphere_direction_bdpt </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>pdf_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Samples a direction uniformly over the unit sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pdf_out</td><td>The Probability Density Function (PDF) of sampling the returned direction, in solid angle measure (1/(4*PI)). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A randomly sampled unit direction vector. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab653062b770735172c3daa2ab51d2c4c" name="ab653062b770735172c3daa2ab51d2c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab653062b770735172c3daa2ab51d2c4c">&#9670;&#160;</a></span>GEOMETRY_EPSILON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double BDPT::GEOMETRY_EPSILON = 1e-8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Small epsilon value for geometric comparisons (e.g., vector lengths, distances) to handle floating-point inaccuracies. </p>

</div>
</div>
<a id="a2b9524ac4202c8d0f8446ec7bd525f1b" name="a2b9524ac4202c8d0f8446ec7bd525f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9524ac4202c8d0f8446ec7bd525f1b">&#9670;&#160;</a></span>ONE_OVER_FOUR_PI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double BDPT::ONE_OVER_FOUR_PI = 1.0 / (4.0 * <a class="el" href="BDPT_8hpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precomputed value of 1/(4*PI). </p>

</div>
</div>
<a id="a7a4847d6ecec82c5533d5c5cee248c0f" name="a7a4847d6ecec82c5533d5c5cee248c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4847d6ecec82c5533d5c5cee248c0f">&#9670;&#160;</a></span>ONE_OVER_PI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double BDPT::ONE_OVER_PI = 1.0 / <a class="el" href="BDPT_8hpp.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precomputed value of 1/PI. </p>

</div>
</div>
<a id="abafbdd2a8f1955dfa015f4e9887a8889" name="abafbdd2a8f1955dfa015f4e9887a8889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafbdd2a8f1955dfa015f4e9887a8889">&#9670;&#160;</a></span>PDF_EPSILON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double BDPT::PDF_EPSILON = 1e-7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Small epsilon value for Probability Density Function (PDF) comparisons to avoid division by zero or instability. </p>

</div>
</div>
<a id="aa723c28285176a297dfbab55f9964eae" name="aa723c28285176a297dfbab55f9964eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa723c28285176a297dfbab55f9964eae">&#9670;&#160;</a></span>RAY_OFFSET_EPSILON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double BDPT::RAY_OFFSET_EPSILON = 1e-4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Small distance to offset rays from surfaces to prevent self-intersection. </p>

</div>
</div>
<a id="a67a92ff05b952759e35747db08a1827f" name="a67a92ff05b952759e35747db08a1827f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a92ff05b952759e35747db08a1827f">&#9670;&#160;</a></span>RR_START_DEPTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int BDPT::RR_START_DEPTH = 3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Depth at which Russian Roulette path termination begins. </p>

</div>
</div>
<a id="ac681c8b8f1bebfa2679882a62f3f76ea" name="ac681c8b8f1bebfa2679882a62f3f76ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac681c8b8f1bebfa2679882a62f3f76ea">&#9670;&#160;</a></span>THROUGHPUT_EPSILON_SQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double BDPT::THROUGHPUT_EPSILON_SQ = 1e-12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Squared epsilon for path throughput magnitude checks; paths with throughput below this are considered negligible. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
